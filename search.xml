<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客</title>
    <url>/2023/03/19/Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo-GitHub-Pages搭建个人博客"><a href="#Hexo-GitHub-Pages搭建个人博客" class="headerlink" title="Hexo + GitHub Pages搭建个人博客"></a>Hexo + GitHub Pages搭建个人博客</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! </p>
<ol>
<li>github创建一个<code>用户名.github.io</code>的仓库。</li>
<li>安装node.js。</li>
<li>安装hexo，<code>npm install hexo-cli -g</code>。</li>
<li>创建本地文件夹<code>hexo init blog</code>，并进行初始化<code>npm install</code>。</li>
<li>修改<code>_config.yml</code>配置文件。</li>
<li>选择自己喜欢的<a href="https://hexo.io/themes/">主题</a>进行更换，下载到<code>themes</code>文件夹下，并在<code>_config.yml</code>更新，不要忘记修改主题中的<code>_config.yml</code>配置文件。</li>
<li>开启分类和标签，<code>hexo new page categories</code>，<code>index.md</code>添加<code>type: &quot;categories&quot;</code>。</li>
<li>本地进行预览<code>hexo server</code>。</li>
<li>没有问题的话就可以进行部署了<code>hexo d -g</code>。</li>
</ol>
<span id="more"></span>

<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ul>
<li><p><code>npm install</code> 报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm -rf ~/.node-gyp</span><br><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line">sudo npm i --unsafe-perm</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ERROR Deployer not found: git</code> 报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>遇到 <code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code> 问题，安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="NEXT主题下开启搜索"><a href="#NEXT主题下开启搜索" class="headerlink" title="NEXT主题下开启搜索"></a>NEXT主题下开启搜索</h2><ol>
<li>安装插件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li><code>_config.yml</code>添加配置文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure></li>
<li>打开主题配置文件开关<code>local_search</code>。</li>
</ol>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p>example：<a href="https://www.aliyun.com/?utm_content=se_1000301881&accounttraceid=52e2158134cd4376ab19089abd0757e9llgh">阿里云</a></p>
<ol>
<li>在终端中 <code>ping ***.github.io</code> 得到一个ip地址，copy下来。</li>
<li>在阿里云域名设置中添加解析：<ul>
<li>主机记录–www，记录类型–A，解析线路–默认不修改，记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
<li>主机记录--@，记录类型–A，解析线路–默认不修改，记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
</ul>
</li>
<li>在GitHub中打开username.github.io仓库中的设置，找到 <code>Custom domain</code> 将自己的域名填入其中，点击保存。</li>
<li>在本地仓库中打开 <code>source</code> 文件夹，添加 <code>CNAME</code> 文件，内容为自己的域名；</li>
<li>重新部署，等待几分钟即可访问。</li>
</ol>
<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><ol>
<li>在GitHub新建一个仓库用于存储图片。</li>
<li>在个人GitHub账户中的 <code>Settings</code> 中选择 <code>Developer settings</code> 创建 <code>Personal access tokens</code>，勾选 <code>repo</code> 一栏即可。</li>
<li>安装PicGo。</li>
<li>配置PicGo，建议使用cdn加速：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/用户名/仓库名</span><br></pre></td></tr></table></figure></li>
<li>配置完成后即可上传图片了。</li>
</ol>
]]></content>
      <categories>
        <category>踩坑指南</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>frame VS bounds</title>
    <url>/2023/03/20/frame%20VS%20bounds/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UIView布局属性"><a href="#UIView布局属性" class="headerlink" title="UIView布局属性"></a>UIView布局属性</h1><ul>
<li><code>frame</code>是在父图层上的位置和大小，CALayer中的frame被bounds、position、transform三个属性约束。</li>
<li><code>bounds</code>是图层内部的，即自身坐标系下的size和orgin。</li>
<li>center属性，在CALayer中对应：<ul>
<li>position，图层的锚点在父图层中的坐标空间位置，依赖父图层的bounds。</li>
<li>anchorPoint，锚点，默认(0.5, 0.5)中心点，超过(0, 1)范围即超出本图层。</li>
</ul>
</li>
</ul>
<p>其计算关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position.x = frame.origin.x + anchorPoint.x * frame.size.width;</span><br><span class="line">position.y = frame.origin.y + anchorPoint.y * frame.size.height;</span><br></pre></td></tr></table></figure>

<p>因此，可以通过旋转、修改锚点等方式来查看区别。通过下面代码可以看出，修改锚点等操作不会影响图层的bounds，bounds是固定的，变化的只有frame。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line"></span><br><span class="line">        let view1 = UIView()</span><br><span class="line">        view1.backgroundColor = .red</span><br><span class="line">        view1.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view.addSubview(view1)</span><br><span class="line">        </span><br><span class="line">        let view2 = UIView()</span><br><span class="line">        view2.backgroundColor = .blue</span><br><span class="line">        view2.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view2.layer.anchorPoint = CGPoint(x: 0, y: 0)</span><br><span class="line">        view.addSubview(view2)</span><br><span class="line">        </span><br><span class="line">        let view3 = UIView()</span><br><span class="line">        view3.backgroundColor = .green</span><br><span class="line">        view3.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view3.transform = CGAffineTransform(rotationAngle: 45)</span><br><span class="line">        view.addSubview(view3)</span><br><span class="line">        </span><br><span class="line">        let view4 = UIView()</span><br><span class="line">        view4.backgroundColor = .yellow</span><br><span class="line">        view4.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view4.layer.position = CGPoint(x: 0, y: 0)</span><br><span class="line">        view.addSubview(view4)</span><br><span class="line">        </span><br><span class="line">        print(&quot;view1 - frame: \(view1.frame) bounds: \(view1.bounds)&quot;)</span><br><span class="line">        print(&quot;view2 - frame: \(view2.frame) bounds: \(view2.bounds)&quot;)</span><br><span class="line">        print(&quot;view3 - frame: \(view3.frame) bounds: \(view3.bounds)&quot;)</span><br><span class="line">        print(&quot;view4 - frame: \(view4.frame) bounds: \(view4.bounds)&quot;)</span><br><span class="line"></span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br></pre></td></tr></table></figure>

<hr>
<p>父视图中和子视图的frame设置先后顺序对渲染过程有影响。通常情况下，frame的宽高和bounds的宽高是相同的，但是当改变了transform的时候，frame的宽高和bounds的宽高可能不再相同。</p>
<h2 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h2><p>frame是动态、不存储的派生属性，根据layer的bounds，position(center)，archorPoint，transform动态计算。</p>
<ul>
<li><p>当改变bounds，position(center)，archorPoint，transform当中的任何一个值时，frame都会发生变化。具体步骤如下：</p>
<ol>
<li>首先根据bounds、position(center)、archorPoint计算出变换前的frame。</li>
<li>根据变换前的frame及transform计算出变换后的frame。</li>
<li>当变换后的frame是一个平行四边形或者不平行于边轴时，返回一个最小的包括变换后的frame的四个顶点的矩形，这个矩形就是真实的frame。</li>
</ol>
</li>
<li><p>当改变frame时，archorPoint，transform不变，bounds和position(center)随之改变。具体步骤如下：</p>
<ol>
<li>首先根据frame及transform计算出变换前的frame。</li>
<li>根据变换前的frame的size修改bounds属性。</li>
<li>根据变换前的frame、archorPoint修改position(center)属性。</li>
</ol>
</li>
</ul>
<h2 id="bounds"><a href="#bounds" class="headerlink" title="bounds"></a>bounds</h2><p>bounds影响子view的位置和大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line"></span><br><span class="line">        let view1 = UIView()</span><br><span class="line">        view1.backgroundColor = .red</span><br><span class="line">        view1.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view.addSubview(view1)</span><br><span class="line">        </span><br><span class="line">        let view2 = UIView()</span><br><span class="line">        view2.backgroundColor = .blue</span><br><span class="line">        view2.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view1.addSubview(view2)</span><br><span class="line">        </span><br><span class="line">        let view3 = UIView()</span><br><span class="line">        view3.backgroundColor = .green</span><br><span class="line">        view3.frame = CGRect(x: 20, y: 20, width: 50, height: 50)</span><br><span class="line">        view2.addSubview(view3)</span><br><span class="line">        </span><br><span class="line">        print(&quot;view1 - frame: \(view1.frame) bounds: \(view1.bounds)&quot;)</span><br><span class="line">        print(&quot;view2 - frame: \(view2.frame) bounds: \(view2.bounds)&quot;)</span><br><span class="line">        print(&quot;view3 - frame: \(view3.frame) bounds: \(view3.bounds)&quot;)</span><br><span class="line">        </span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CoreAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-手势冲突</title>
    <url>/2023/03/22/iOS-%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引言：当触摸屏幕之后发生了什么？</p>
<ol>
<li>硬件层面，手指触摸会在屏幕上组成一个小电容，在屏幕接触点会被吸走的一部分电流流向四个角落的时间差可以得到触摸点的位置。</li>
<li>屏幕触摸事件的分发：IPC进程间通信<ol>
<li><code>IOKit</code>将触摸事件封装成<code>IOHIDEvent</code>对象，并通过<code>mach port</code>转发<code>SpringBoard</code>（负责管理主屏幕的基础程序）。</li>
<li><code>SpringBoard</code>继续将<code>IOHIDEvent</code>事件通过<code>mach port</code>转发给当前app的主线程。</li>
</ol>
</li>
<li>RunLoop：<ol>
<li>前台app主线程runloop申请一个<code>mach port</code>用于监听<code>IOHIDEvent</code>的<code>Source1</code>事件，触发<code>Source1</code>回调，并在<code>Source1</code>回调内部分发<code>Source0</code>回调。</li>
<li><code>Source0</code>事件的回调方法<code>__UIApplicationHandleEventQueue()</code>会将收到的<code>IOHIDEvent</code>事件封装成<code>UIEvent</code>事件，并调用<code>UIApplication</code>的<code>sendEvent:</code>方法将<code>UIEvent</code>传给<code>UIWindow</code>。</li>
</ol>
</li>
<li>触摸事件响应者：通过判断<code>UIEvent</code>中的每个<code>UITouch</code>的<code>(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code>寻找最佳的响应者。</li>
</ol>
<span id="more"></span>

<h2 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h2><p><code>UITouch</code>可以说是触摸的基本单位。<br>每个手指每次触摸屏幕都会生成一个<code>UITouch</code>对象，多个手指触摸对应着多个<code>UITouch</code>对象；多次触摸同一位置时不会生成多个<code>UITouch</code>对象，而是会对其计数+1。<br>当手指离开屏幕一段时间后，<code>UITouch</code>会被销毁。</p>
<p><code>UITouch</code>的基本属性&amp;方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property(nonatomic,readonly) NSTimeInterval      timestamp;  // 触摸时间</span><br><span class="line">@property(nonatomic,readonly) UITouchPhase        phase;      // 触摸阶段：开始、移动、结束、取消</span><br><span class="line">@property(nonatomic,readonly) NSUInteger          tapCount;   // UITouch对象计数</span><br><span class="line">@property(nonatomic,readonly) UITouchType         type API_AVAILABLE(ios(9.0)); // 类型：直接接触、间接接触、触摸笔等</span><br><span class="line"></span><br><span class="line">// majorRadius and majorRadiusTolerance are in points</span><br><span class="line">// The majorRadius will be accurate +/- the majorRadiusTolerance</span><br><span class="line">@property(nonatomic,readonly) CGFloat majorRadius API_AVAILABLE(ios(8.0));  // 触摸半径</span><br><span class="line">@property(nonatomic,readonly) CGFloat majorRadiusTolerance API_AVAILABLE(ios(8.0));</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIWindow                        *window;</span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIView                          *view;</span><br><span class="line">@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers API_AVAILABLE(ios(3.2));</span><br><span class="line"></span><br><span class="line">- (CGPoint)locationInView:(nullable UIView *)view;  // 触摸位置</span><br><span class="line">- (CGPoint)previousLocationInView:(nullable UIView *)view;  // 上一个触摸位置</span><br></pre></td></tr></table></figure>

<h2 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h2><p><code>UIEvent</code>是用来描述单一事件的对象对象，包含了所有触发该事件的对象集合（UITouch等）。<br>每产生一个事件，就对应生成一个<code>UIEvent</code>对象。</p>
<p><code>UIEvent</code>的基本属性&amp;方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property(nonatomic,readonly) UIEventType     type API_AVAILABLE(ios(3.0));</span><br><span class="line">@property(nonatomic,readonly) UIEventSubtype  subtype API_AVAILABLE(ios(3.0));</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly) NSTimeInterval  timestamp;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) UIKeyModifierFlags modifierFlags API_AVAILABLE(ios(13.4), tvos(13.4)) API_UNAVAILABLE(watchos);</span><br><span class="line">@property (nonatomic, readonly) UIEventButtonMask buttonMask API_AVAILABLE(ios(13.4)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture API_AVAILABLE(ios(3.2));</span><br><span class="line"></span><br><span class="line">// An array of auxiliary UITouch’s for the touch events that did not get delivered for a given main touch. This also includes an auxiliary version of the main touch itself.</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)coalescedTouchesForTouch:(UITouch *)touch API_AVAILABLE(ios(9.0));</span><br><span class="line"></span><br><span class="line">// An array of auxiliary UITouch’s for touch events that are predicted to occur for a given main touch. These predictions may not exactly match the real behavior of the touch as it moves, so they should be interpreted as an estimate.</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)predictedTouchesForTouch:(UITouch *)touch API_AVAILABLE(ios(9.0));</span><br></pre></td></tr></table></figure>

<h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p><code>UIResponder</code>是iOS用于处理用户事件的API。事件响应者可以是继承自<code>UIResponder</code>的任何子类。</p>
<img data-src="/2023/03/22/iOS-%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE.png" class>
<p>关于<strong>响应者链</strong>：</p>
<ul>
<li>事件由父视图-&gt;子视图，查找最佳响应者；</li>
<li>事件由子视图-&gt;父视图在响应链进行传递，执行对应操作。</li>
</ul>
<h3 id="UIView-的-hitTest"><a href="#UIView-的-hitTest" class="headerlink" title="UIView 的 hitTest"></a>UIView 的 hitTest</h3><p>一个事件的响应者的完成经历的两个过程：</p>
<ol>
<li>hitTest方法命中视图和响应者链确定响应者。</li>
<li>hitTest方法进行查找，直到找到命中者，然后从命中者视图沿着响应链往上层寻找最终响应者。（形成响应者链）</li>
</ol>
<p><code>hitTest</code>的查找顺序：</p>
<ul>
<li>从父视图到子视图，即从<code>UIApplication</code>开始往下调用。</li>
<li>同视图层级间，同栈一样先入后出。</li>
</ul>
<p>通过调用栈复现原理伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</span><br><span class="line">    if ([self pointInside:point withEvent:event] == NO) return nil;</span><br><span class="line"></span><br><span class="line">    // 从后往前遍历子控件</span><br><span class="line">    NSInteger count = self.subviews.count;</span><br><span class="line">    for (NSInteger i = count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        UIView *childView = self.subviews[i]; // 获取子视图</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView];  // 坐标系转换</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line">        if (fitView) &#123; // 寻找到最合适的view</span><br><span class="line">            return fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 循环结束,表示没有比自己更合适的view</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不能响应触摸事件的几种Case：</p>
<ol>
<li>触摸点超出视图范围；</li>
<li>UIView的userInteractionEnabled &#x3D; NO；</li>
<li>UIView.hidden &#x3D; YES;</li>
<li>UIView.alpha &lt; 0.01;</li>
</ol>
<p>当子视图超出父视图时，可通过重写父视图的<code>hitTest</code>方法，来响应子视图的点击事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    UIView *view = [super hitTest:point withEvent:event];</span><br><span class="line">    // 超出父视图响应区域时，遍历子view区域</span><br><span class="line">    if (view == nil) &#123;</span><br><span class="line">        for (UIView *subView in self.subviews) &#123;</span><br><span class="line">            // 转换坐标系</span><br><span class="line">            CGPoint p = [subView convertPoint:point fromView:self];</span><br><span class="line">            if (CGRectContainsPoint(subView.bounds, p)) &#123;</span><br><span class="line">                view = subView;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UIResponder-1"><a href="#UIResponder-1" class="headerlink" title="UIResponder"></a>UIResponder</h3><p>关于<code>UIResponder</code>需要了解的一些属性&amp;方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// hitTest查找第一响应者的过程会形成一个响应者链，app会优先调用第一响应者处理事件，如果第一响应者不能处理事件，则调用`nextResponder`，直到找到响应链中能处理该事件的对象，都不能响应则抛弃该事件。</span><br><span class="line">@property(nonatomic, readonly, nullable) UIResponder *nextResponder;</span><br><span class="line">@property(nonatomic, readonly) BOOL canBecomeFirstResponder;    // default is NO</span><br><span class="line">- (BOOL)becomeFirstResponder;</span><br><span class="line">@property(nonatomic, readonly) BOOL canResignFirstResponder;    // default is YES</span><br><span class="line">- (BOOL)resignFirstResponder;</span><br><span class="line">@property(nonatomic, readonly) BOOL isFirstResponder;</span><br><span class="line"></span><br><span class="line">// 响应触摸事件：触摸对象集合、事件对象。</span><br><span class="line">// touchesBegan默认不对事件进行处理，单纯将事件沿着默认的响应链传递。如果要拦截事件，且不传递，重写方法但不调用父类该方法。</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; </span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches API_AVAILABLE(ios(9.1));</span><br></pre></td></tr></table></figure>

<h2 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h2><p>手势类型有很多种（子类多），API中使用最多的就是<code>- (void)addTarget:(id)target action:(SEL)action;</code>方法了，通常在自定义手势操作时会依赖<code>Began、Changed、Ended、Cancelled</code>等<code>UIGestureRecognizerState</code>状态来进行响应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123;</span><br><span class="line">    UIGestureRecognizerStatePossible, </span><br><span class="line">    UIGestureRecognizerStateBegan,     </span><br><span class="line">    UIGestureRecognizerStateChanged,    </span><br><span class="line">    UIGestureRecognizerStateEnded,      </span><br><span class="line">    UIGestureRecognizerStateCancelled,  </span><br><span class="line">    UIGestureRecognizerStateFailed,     </span><br><span class="line">    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>UIGestureRecognizer</code>同样可以响应<code>touchesBegan</code>等方法，相关声明位于<code>UIGestureRecognizerSubclass</code>中。</p>
<p><code>UIEvent</code>事件处理过程：手势上下文<code>UIGestureEnvironment</code>收到事件，通知给相关的<code>UIGestureRecognizer</code>，同时会通过<code>delegate</code>方法来判断是否能够对触摸事件进行响应。</p>
<p>手势冲突处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将手势置于另一手势优先级之下，只有另一手势识别失败才会识别该手势；另一手势识别成功，该手势状态变为识别失败。</span><br><span class="line">- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer;</span><br><span class="line">// 返回YES第一个手势失效（适用于不同层级间，返回NO不保证生效，单一控制优先级）</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer API_AVAILABLE(ios(7.0));</span><br><span class="line">// 返回YES第二个手势失效（适用于不同层级间，返回NO不保证生效，单一控制优先级）</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer API_AVAILABLE(ios(7.0));</span><br></pre></td></tr></table></figure>

<p>UIGestureRecognizer VS. UIResponder:</p>
<img data-src="/2023/03/22/iOS-%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81/UIGestureRecognizer%E5%92%8CUIResponder.svg" class>

<h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p><code>UIButton</code>继承自<code>UIControl</code>继承自<code>UIView</code>继承自<code>UIResponder</code>继承自<code>NSObject</code>。</p>
<p><code>UIControl</code>通过<code>Target-Action</code>机制处理触摸事件。</p>
<ul>
<li><code>Target-Action</code>机制通过<code>- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event;</code>方法通知<code>UIApplication</code>。</li>
<li><code>UIApplication</code>通过<code>- (BOOL)sendAction:(SEL)action to:(nullable id)target from:(nullable id)sender forEvent:(nullable UIEvent *)event;</code>方法向<code>target</code>发送<code>action</code>。</li>
<li><code>target == nil</code>时会沿着响应链进行寻找。</li>
</ul>
<p><code>UIControl</code>将手势与<code>UIView</code>进行绑定，并对<code>UIResponder</code>事件进行了重写，会阻断响应链（重写了对应实现）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    @objc func clickBtn() &#123;</span><br><span class="line">        print(&quot;======click======&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func clickView() &#123;</span><br><span class="line">        print(&quot;======clickView======&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line">        let tap = UITapGestureRecognizer(target: self, action: #selector(clickView))</span><br><span class="line">        view.addGestureRecognizer(tap)</span><br><span class="line">        </span><br><span class="line">        let btn = UIButton()</span><br><span class="line">        btn.backgroundColor = .orange</span><br><span class="line">        btn.frame = CGRect(x: 100, y: 200, width: 100, height: 100)</span><br><span class="line">        // isUserInteractionEnabled默认开启，会阻断响应链</span><br><span class="line">        //btn.isUserInteractionEnabled = false;</span><br><span class="line">        btn.addTarget(self, action: #selector(clickBtn), for: .touchUpInside)</span><br><span class="line">        view.addSubview(btn)</span><br><span class="line">        </span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br></pre></td></tr></table></figure>

<hr>
<p>Tips：</p>
<ul>
<li>响应优先级：<code>UIControl</code> &gt; <code>UIGestureRecognizer</code> &gt; <code>UITouch</code></li>
<li>userInteractionEnabled，UIView的交互属性。</li>
<li><code>exclusiveTouch</code>，UIView会独占整个Touch事件，但不影响Gesture。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIResponder</tag>
        <tag>UIGestureRecognizer</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS实现点九图效果</title>
    <url>/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>点九图是Android特有的切图方式，iOS也可以通过简单的图片操作来实现（调用<code>UIImage</code>的<code>resizableImage</code>方法即可）。</p>
<p>iOS开发中经常会遇到比较复杂的异形图的绘制或者添加一些纹理，比较简单的办法就是找UI同学给个切图。但是固定图片在不同屏幕大小机型上会被拉伸，效果会比较差。因此，可以使用点九图（Android特有说法）来实现复杂处理。比较典型的例子就是WeChat中的聊天输入框。</p>
<span id="more"></span>

<p><a href="https://zhuanlan.zhihu.com/p/97138527">点九图的原理：</a></p>
<img data-src="/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/%E7%82%B9%E4%B9%9D%E5%9B%BE%E5%8E%9F%E7%90%86.png" class>
<p>对于一张图片，可以通过上下左右分别绘制两天直线来对图片进行划分，将图片划分为9个区域。在该区域中，四个角落即1、2、3、4区域是不可拉伸的，其它区域均可被拉伸。<br>实现原理则是，程序通过识别图片四周的1px的直线（需要设计给出），实现对拉伸区域（6左边和5上边）和文本区域（7右边和8下边）的定义。</p>
<ul>
<li>拉伸区域：6左边可实现纵向拉伸，5上边可实现横向拉伸。</li>
<li>文本区域：7右边和8下边来避免文本区域超出圆角区域。</li>
</ul>
<p>随便找了一张图来实践一下，<br>对下述图片进行操作：</p>
<img data-src="/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/end_time.jpeg" class>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//: A UIKit based Playground for presenting user interface</span><br><span class="line">  </span><br><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line">        </span><br><span class="line">        let img = UIImageView()</span><br><span class="line">        if let path = Bundle.main.path(forResource: &quot;end_time&quot;, ofType: &quot;jpeg&quot;) &#123;</span><br><span class="line">            if let data: Data = NSData(contentsOfFile: path) as Data? &#123;</span><br><span class="line">                let image = UIImage(data: data)</span><br><span class="line">                img.image = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        img.frame = CGRect(x: 100, y: 0, width: 120, height: 48)</span><br><span class="line">        view.addSubview(img)</span><br><span class="line">        </span><br><span class="line">        let img1 = UIImageView()</span><br><span class="line">//        img1.contentMode = .topLeft   // 默认使用</span><br><span class="line">        img1.image = UIImage(named: &quot;end_time.jpeg&quot;)</span><br><span class="line">        img1.frame = CGRect(x: 100, y: 100, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img1)</span><br><span class="line">        </span><br><span class="line">        let img2 = UIImageView()</span><br><span class="line">        img2.contentMode = .scaleAspectFit</span><br><span class="line">        img2.image = UIImage(named: &quot;end_time.jpeg&quot;)</span><br><span class="line">        img2.frame = CGRect(x: 100, y: 200, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img2)</span><br><span class="line">        </span><br><span class="line">        let img3 = UIImageView()</span><br><span class="line">        img3.image = UIImage(named: &quot;end_time.jpeg&quot;)?.resizableImage(withCapInsets: .init(top: 0, left: 0, bottom: 0, right: 0), resizingMode: .stretch)</span><br><span class="line">        img3.frame = CGRect(x: 100, y: 300, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img3)</span><br><span class="line">        </span><br><span class="line">        let img4 = UIImageView()</span><br><span class="line">        img4.image = UIImage(named: &quot;end_time.jpeg&quot;)?.resizableImage(withCapInsets: .init(top: 0, left: 40, bottom: 0, right: 50), resizingMode: .stretch)</span><br><span class="line">        img4.frame = CGRect(x: 100, y: 400, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img4)</span><br><span class="line">        </span><br><span class="line">        let img5 = UIImageView()</span><br><span class="line">        img5.image = UIImage(named: &quot;end_time.jpeg&quot;)?.resizableImage(withCapInsets: .init(top: 20, left: 40, bottom: 20, right: 50), resizingMode: .stretch)</span><br><span class="line">        img5.frame = CGRect(x: 100, y: 500, width: 200, height: 100)</span><br><span class="line">        view.addSubview(img5)</span><br><span class="line">        </span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现代码效果如下：</p>
<img data-src="/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C.png" class>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>我的个税退税</title>
    <url>/2023/03/20/%E6%88%91%E7%9A%84%E4%B8%AA%E7%A8%8E%E9%80%80%E7%A8%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="个人所得税"><a href="#个人所得税" class="headerlink" title="个人所得税"></a>个人所得税</h1><p>我要办税之综合所得年度汇算，在收入部分，对于年终奖部分，如果收入比较低（几千块&#x2F;月）来说，可能合并计税会比较划算；而对于身边绝大部分朋友，还是单独计税更合适。这两种计税方式可以都试下，看看到底哪个更适合自己。其次，是一些附加税的扣除。</p>
<h2 id="专项附加税扣除"><a href="#专项附加税扣除" class="headerlink" title="专项附加税扣除"></a>专项附加税扣除</h2><ul>
<li>子女教育，这个目前还没有，先不考虑</li>
<li>继续教育，这部分还有提升空间，分为两部分：<ul>
<li>学历继续教育，说实话，目前来说也不再考虑了😅</li>
<li>职业资格继续教育，这部分还可以技术提升下，有些需要一定的时间精力的，比如软考中级证书、初级会计资格证等，还有一些是不需要花费多少时间的，这种的就比较友好了。</li>
</ul>
</li>
<li>大病医疗，还没有，也不希望有 嘿嘿</li>
<li>住房贷款利息，目前还没有，快了快了</li>
<li>住房租金<ul>
<li>有一定要如实填写，这部分能有一万八的抵税额度，公司发的工资虽然已经扣除过了，但是如果自己不申报会把这部分的额度重新计税。</li>
</ul>
</li>
<li>赡养老人，父母到60岁才可以用，别的没办法</li>
<li>3岁以下婴幼儿护照，有了孩子再说吧，感觉离我还很遥远</li>
</ul>
<h2 id="职业资格认证"><a href="#职业资格认证" class="headerlink" title="职业资格认证"></a>职业资格认证</h2><h3 id="阿⾥云Apsara-Clouder云计算专项技能认证"><a href="#阿⾥云Apsara-Clouder云计算专项技能认证" class="headerlink" title="阿⾥云Apsara Clouder云计算专项技能认证"></a><a href="https://edu.aliyun.com/certification/cldc15">阿⾥云Apsara Clouder云计算专项技能认证</a></h3><p>网站：<a href="https://edu.aliyun.com/certification/cldc15">https://edu.aliyun.com/certification/cldc15</a></p>
<p><em>0成本考证填报个税纳税额减免3600</em></p>
<p>题目比较固定，大部分题目网上很多答案，直接搜就可以了。贴一个自用的链接答案 <a href="https://blog.csdn.net/spacehhy/article/details/128917928">https://blog.csdn.net/spacehhy/article/details/128917928</a></p>
<p>申报：<br>    1. <code>职业资格继续教育类型</code>选择<code>专业技术人员职业资格</code>；<br>    2. 发证日期 &amp; 证书编号，填写证书上的信息；<br>    3. <code>证书名称</code>选择<code>计算机技术与软件专业技术资格</code>；<br>    4. <code>发证机关</code>选择<code>阿里云</code>。</p>
]]></content>
      <categories>
        <category>工作相关</category>
      </categories>
      <tags>
        <tag>个人所得税</tag>
      </tags>
  </entry>
  <entry>
    <title>捕鼠器の故事</title>
    <url>/2023/03/25/%E6%8D%95%E9%BC%A0%E5%99%A8%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>
        <div id="aplayer-sUqYyeIS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-sUqYyeIS"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "朗读这篇文章",
              author: "章肿鱼",
              url: "捕鼠器的故事.mp3",
              pic: "/images/avatar.jpeg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<p><strong>从收到一个需求，去做一件事，到解决某一类问题，这是一个坎。</strong></p>
<span id="more"></span>

<p>假设你是一个工程师，这时候你被安排了一项任务“改进捕鼠器”。<br>你就要思考🤔：这个捕鼠器要怎么改进呢？<br>通常做法：</p>
<ul>
<li>最简单的，去搜索业界类似的Case，看有没有类似的优化（借鉴已有先进经验）；</li>
<li>比较负责一点的同学，会考虑为什么现在的捕鼠器需要改进（捕鼠的效果差的原因），即实际产品的现存问题；</li>
</ul>
<p>改造过程就比作积累技术经验，一般的做完需求就stop了，不会再继续深究，获得的只限于技术的熟练或积累了类似经验。<br>进阶一步的话，就需要考虑为什么要去改进捕鼠器呢？如果回答是为了捕老鼠，这个回答无法反驳，但只是这样的话，在捕老鼠这个问题上很快就会达到一个瓶颈（毕竟技术是有限制的，<strong>捕鼠器改进再好，老鼠不过去，也很难抓到老鼠</strong>）。</p>
<p>改造完成后通过观察（自测、内测、众测等）发现，核心问题是捕鼠器的位置不对。（这是关键点，<strong>一个RD对一个任务能够从解决问题到提出新问题是一个突破</strong>）<br>针对这个发现，已经不是捕鼠器的问题了，而是环境的限制。<br>此时就会想，使用捕鼠器的原因，本质上其实是为了根除老鼠。所以，捕鼠器本身不重要，重要的是能够杀死老鼠。<br>鉴于此，就有了进一步横向思考的可能，比如说发明捕鼠药，有的话直接购买也可以的。（这时会发现自己已经有了新的需求，如何改进灭鼠药的效果😂）</p>
<p>其实这个故事，灭鼠不是关键，灭鼠是为了保护粮食。当把老鼠都消灭之后发现粮食还是保不住（比如，被雨水淋坏了等）。<br>再继续深入就会发现，最终的OKR其实是为了保护粮食。那么，如何定义保护粮食是否有提升呢？比如，粮食留存率等等，这时候就可以去定义粮食保护的评估方法，进而成立粮食保护小组（可以带团队创业了）。</p>
<img data-src="/2023/03/25/%E6%8D%95%E9%BC%A0%E5%99%A8%E7%9A%84%E6%95%85%E4%BA%8B/%E6%A6%82%E8%A7%88.png" class>
<blockquote>
<p>杨震原说过，对研发来说，前提是能够把现有本职工作做好，如果能进一步去思考问题的本质，能够跟最高的目标对齐，你的工作实际上会更加主动，也能更好发挥自己的能力。</p>
</blockquote>
<p>所以，经常想想自己在做的问题，“你在解决什么问题？”；<br>假如你是leader，还可以对员工继续提问：“这真的是你的问题吗😏”</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
