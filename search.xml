<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客</title>
    <url>/2023/03/19/Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo-GitHub-Pages搭建个人博客"><a href="#Hexo-GitHub-Pages搭建个人博客" class="headerlink" title="Hexo + GitHub Pages搭建个人博客"></a>Hexo + GitHub Pages搭建个人博客</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! </p>
<ol>
<li>github创建一个<code>用户名.github.io</code>的仓库。</li>
<li>安装node.js。</li>
<li>安装hexo，<code>npm install hexo-cli -g</code>。</li>
<li>创建本地文件夹<code>hexo init blog</code>，并进行初始化<code>npm install</code>。</li>
<li>修改<code>_config.yml</code>配置文件。</li>
<li>选择自己喜欢的<a href="https://hexo.io/themes/">主题</a>进行更换，下载到<code>themes</code>文件夹下，并在<code>_config.yml</code>更新，不要忘记修改主题中的<code>_config.yml</code>配置文件。</li>
<li>开启分类和标签，<code>hexo new page categories</code>，<code>index.md</code>添加<code>type: &quot;categories&quot;</code>。</li>
<li>本地进行预览<code>hexo server</code>。</li>
<li>没有问题的话就可以进行部署了<code>hexo d -g</code>。</li>
</ol>
<span id="more"></span>

<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ul>
<li><p><code>npm install</code> 报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm -rf ~/.node-gyp</span><br><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line">sudo npm i --unsafe-perm</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ERROR Deployer not found: git</code> 报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>遇到 <code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code> 问题，安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="NEXT主题下开启搜索"><a href="#NEXT主题下开启搜索" class="headerlink" title="NEXT主题下开启搜索"></a>NEXT主题下开启搜索</h2><ol>
<li>安装插件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li><code>_config.yml</code>添加配置文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure></li>
<li>打开主题配置文件开关<code>local_search</code>。</li>
</ol>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p>example：<a href="https://www.aliyun.com/?utm_content=se_1000301881&accounttraceid=52e2158134cd4376ab19089abd0757e9llgh">阿里云</a></p>
<ol>
<li>在终端中 <code>ping ***.github.io</code> 得到一个ip地址，copy下来。</li>
<li>在阿里云域名设置中添加解析：<ul>
<li>主机记录–www，记录类型–A，解析线路–默认不修改，记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
<li>主机记录--@，记录类型–A，解析线路–默认不修改，记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
</ul>
</li>
<li>在GitHub中打开username.github.io仓库中的设置，找到 <code>Custom domain</code> 将自己的域名填入其中，点击保存。</li>
<li>在本地仓库中打开 <code>source</code> 文件夹，添加 <code>CNAME</code> 文件，内容为自己的域名；</li>
<li>重新部署，等待几分钟即可访问。</li>
</ol>
<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><ol>
<li>在GitHub新建一个仓库用于存储图片。</li>
<li>在个人GitHub账户中的 <code>Settings</code> 中选择 <code>Developer settings</code> 创建 <code>Personal access tokens</code>，勾选 <code>repo</code> 一栏即可。</li>
<li>安装PicGo。</li>
<li>配置PicGo，建议使用cdn加速：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/用户名/仓库名</span><br></pre></td></tr></table></figure></li>
<li>配置完成后即可上传图片了。</li>
</ol>
]]></content>
      <categories>
        <category>踩坑指南</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>XCode之代码块</title>
    <url>/2023/03/31/XCode%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<p>新建代码块：</p>
<img data-src="/2023/03/31/XCode%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%96%B0%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%9D%97.png" class>
<ol>
<li>在XCode工程中右键，选择<code>create code snippet</code>。</li>
<li>编辑代码块内容，关联属性使用<code>&lt;#name#&gt;</code>来设置。</li>
<li>设置快捷键。</li>
</ol>
<p>代码块的使用：</p>
<ol>
<li>输入代码块中设置的快捷指令，<strong>如果没有提示可点击<code>esc</code>键</strong>。</li>
<li>如果没有设置快捷指令，可点击右上角的<code>+</code>键，找到想输入的代码块双击。</li>
</ol>
<p>代码块的保存位置:<br><code>/Users/bytedance/Library/Developer/Xcode/UserData/CodeSnippets</code>，<br>更新后需要重启XCode才会生效😯</p>
]]></content>
      <categories>
        <category>XCode</category>
      </categories>
      <tags>
        <tag>Code Snippets</tag>
      </tags>
  </entry>
  <entry>
    <title>frame VS bounds</title>
    <url>/2023/03/20/frame%20VS%20bounds/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UIView布局属性"><a href="#UIView布局属性" class="headerlink" title="UIView布局属性"></a>UIView布局属性</h1><ul>
<li><code>frame</code>是在父图层上的位置和大小，CALayer中的frame被bounds、position、transform三个属性约束。</li>
<li><code>bounds</code>是图层内部的，即自身坐标系下的size和orgin。</li>
<li>center属性，在CALayer中对应：<ul>
<li>position，图层的锚点在父图层中的坐标空间位置，依赖父图层的bounds。</li>
<li>anchorPoint，锚点，默认(0.5, 0.5)中心点，超过(0, 1)范围即超出本图层。</li>
</ul>
</li>
</ul>
<p>其计算关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position.x = frame.origin.x + anchorPoint.x * frame.size.width;</span><br><span class="line">position.y = frame.origin.y + anchorPoint.y * frame.size.height;</span><br></pre></td></tr></table></figure>

<p>因此，可以通过旋转、修改锚点等方式来查看区别。通过下面代码可以看出，修改锚点等操作不会影响图层的bounds，bounds是固定的，变化的只有frame。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line"></span><br><span class="line">        let view1 = UIView()</span><br><span class="line">        view1.backgroundColor = .red</span><br><span class="line">        view1.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view.addSubview(view1)</span><br><span class="line">        </span><br><span class="line">        let view2 = UIView()</span><br><span class="line">        view2.backgroundColor = .blue</span><br><span class="line">        view2.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view2.layer.anchorPoint = CGPoint(x: 0, y: 0)</span><br><span class="line">        view.addSubview(view2)</span><br><span class="line">        </span><br><span class="line">        let view3 = UIView()</span><br><span class="line">        view3.backgroundColor = .green</span><br><span class="line">        view3.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view3.transform = CGAffineTransform(rotationAngle: 45)</span><br><span class="line">        view.addSubview(view3)</span><br><span class="line">        </span><br><span class="line">        let view4 = UIView()</span><br><span class="line">        view4.backgroundColor = .yellow</span><br><span class="line">        view4.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view4.layer.position = CGPoint(x: 0, y: 0)</span><br><span class="line">        view.addSubview(view4)</span><br><span class="line">        </span><br><span class="line">        print(&quot;view1 - frame: \(view1.frame) bounds: \(view1.bounds)&quot;)</span><br><span class="line">        print(&quot;view2 - frame: \(view2.frame) bounds: \(view2.bounds)&quot;)</span><br><span class="line">        print(&quot;view3 - frame: \(view3.frame) bounds: \(view3.bounds)&quot;)</span><br><span class="line">        print(&quot;view4 - frame: \(view4.frame) bounds: \(view4.bounds)&quot;)</span><br><span class="line"></span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br></pre></td></tr></table></figure>

<hr>
<p>父视图中和子视图的frame设置先后顺序对渲染过程有影响。通常情况下，frame的宽高和bounds的宽高是相同的，但是当改变了transform的时候，frame的宽高和bounds的宽高可能不再相同。</p>
<h2 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h2><p>frame是动态、不存储的派生属性，根据layer的bounds，position(center)，archorPoint，transform动态计算。</p>
<ul>
<li><p>当改变bounds，position(center)，archorPoint，transform当中的任何一个值时，frame都会发生变化。具体步骤如下：</p>
<ol>
<li>首先根据bounds、position(center)、archorPoint计算出变换前的frame。</li>
<li>根据变换前的frame及transform计算出变换后的frame。</li>
<li>当变换后的frame是一个平行四边形或者不平行于边轴时，返回一个最小的包括变换后的frame的四个顶点的矩形，这个矩形就是真实的frame。</li>
</ol>
</li>
<li><p>当改变frame时，archorPoint，transform不变，bounds和position(center)随之改变。具体步骤如下：</p>
<ol>
<li>首先根据frame及transform计算出变换前的frame。</li>
<li>根据变换前的frame的size修改bounds属性。</li>
<li>根据变换前的frame、archorPoint修改position(center)属性。</li>
</ol>
</li>
</ul>
<h2 id="bounds"><a href="#bounds" class="headerlink" title="bounds"></a>bounds</h2><p>bounds影响子view的位置和大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line"></span><br><span class="line">        let view1 = UIView()</span><br><span class="line">        view1.backgroundColor = .red</span><br><span class="line">        view1.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view.addSubview(view1)</span><br><span class="line">        </span><br><span class="line">        let view2 = UIView()</span><br><span class="line">        view2.backgroundColor = .blue</span><br><span class="line">        view2.frame = CGRect(x: 30, y: 30, width: 50, height: 50)</span><br><span class="line">        view1.addSubview(view2)</span><br><span class="line">        </span><br><span class="line">        let view3 = UIView()</span><br><span class="line">        view3.backgroundColor = .green</span><br><span class="line">        view3.frame = CGRect(x: 20, y: 20, width: 50, height: 50)</span><br><span class="line">        view2.addSubview(view3)</span><br><span class="line">        </span><br><span class="line">        print(&quot;view1 - frame: \(view1.frame) bounds: \(view1.bounds)&quot;)</span><br><span class="line">        print(&quot;view2 - frame: \(view2.frame) bounds: \(view2.bounds)&quot;)</span><br><span class="line">        print(&quot;view3 - frame: \(view3.frame) bounds: \(view3.bounds)&quot;)</span><br><span class="line">        </span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CoreAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-手势冲突</title>
    <url>/2023/03/22/iOS-%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引言：当触摸屏幕之后发生了什么？</p>
<ol>
<li>硬件层面，手指触摸会在屏幕上组成一个小电容，在屏幕接触点会被吸走的一部分电流流向四个角落的时间差可以得到触摸点的位置。</li>
<li>屏幕触摸事件的分发：IPC进程间通信<ol>
<li><code>IOKit</code>将触摸事件封装成<code>IOHIDEvent</code>对象，并通过<code>mach port</code>转发<code>SpringBoard</code>（负责管理主屏幕的基础程序）。</li>
<li><code>SpringBoard</code>继续将<code>IOHIDEvent</code>事件通过<code>mach port</code>转发给当前app的主线程。</li>
</ol>
</li>
<li>RunLoop：<ol>
<li>前台app主线程runloop申请一个<code>mach port</code>用于监听<code>IOHIDEvent</code>的<code>Source1</code>事件，触发<code>Source1</code>回调，并在<code>Source1</code>回调内部分发<code>Source0</code>回调。</li>
<li><code>Source0</code>事件的回调方法<code>__UIApplicationHandleEventQueue()</code>会将收到的<code>IOHIDEvent</code>事件封装成<code>UIEvent</code>事件，并调用<code>UIApplication</code>的<code>sendEvent:</code>方法将<code>UIEvent</code>传给<code>UIWindow</code>。</li>
</ol>
</li>
<li>触摸事件响应者：通过判断<code>UIEvent</code>中的每个<code>UITouch</code>的<code>(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code>寻找最佳的响应者。</li>
</ol>
<span id="more"></span>

<h2 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h2><p><code>UITouch</code>可以说是触摸的基本单位。<br>每个手指每次触摸屏幕都会生成一个<code>UITouch</code>对象，多个手指触摸对应着多个<code>UITouch</code>对象；多次触摸同一位置时不会生成多个<code>UITouch</code>对象，而是会对其计数+1。<br>当手指离开屏幕一段时间后，<code>UITouch</code>会被销毁。</p>
<p><code>UITouch</code>的基本属性&amp;方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property(nonatomic,readonly) NSTimeInterval      timestamp;  // 触摸时间</span><br><span class="line">@property(nonatomic,readonly) UITouchPhase        phase;      // 触摸阶段：开始、移动、结束、取消</span><br><span class="line">@property(nonatomic,readonly) NSUInteger          tapCount;   // UITouch对象计数</span><br><span class="line">@property(nonatomic,readonly) UITouchType         type API_AVAILABLE(ios(9.0)); // 类型：直接接触、间接接触、触摸笔等</span><br><span class="line"></span><br><span class="line">// majorRadius and majorRadiusTolerance are in points</span><br><span class="line">// The majorRadius will be accurate +/- the majorRadiusTolerance</span><br><span class="line">@property(nonatomic,readonly) CGFloat majorRadius API_AVAILABLE(ios(8.0));  // 触摸半径</span><br><span class="line">@property(nonatomic,readonly) CGFloat majorRadiusTolerance API_AVAILABLE(ios(8.0));</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIWindow                        *window;</span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIView                          *view;</span><br><span class="line">@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers API_AVAILABLE(ios(3.2));</span><br><span class="line"></span><br><span class="line">- (CGPoint)locationInView:(nullable UIView *)view;  // 触摸位置</span><br><span class="line">- (CGPoint)previousLocationInView:(nullable UIView *)view;  // 上一个触摸位置</span><br></pre></td></tr></table></figure>

<h2 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h2><p><code>UIEvent</code>是用来描述单一事件的对象对象，包含了所有触发该事件的对象集合（UITouch等）。<br>每产生一个事件，就对应生成一个<code>UIEvent</code>对象。</p>
<p><code>UIEvent</code>的基本属性&amp;方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property(nonatomic,readonly) UIEventType     type API_AVAILABLE(ios(3.0));</span><br><span class="line">@property(nonatomic,readonly) UIEventSubtype  subtype API_AVAILABLE(ios(3.0));</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly) NSTimeInterval  timestamp;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) UIKeyModifierFlags modifierFlags API_AVAILABLE(ios(13.4), tvos(13.4)) API_UNAVAILABLE(watchos);</span><br><span class="line">@property (nonatomic, readonly) UIEventButtonMask buttonMask API_AVAILABLE(ios(13.4)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture API_AVAILABLE(ios(3.2));</span><br><span class="line"></span><br><span class="line">// An array of auxiliary UITouch’s for the touch events that did not get delivered for a given main touch. This also includes an auxiliary version of the main touch itself.</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)coalescedTouchesForTouch:(UITouch *)touch API_AVAILABLE(ios(9.0));</span><br><span class="line"></span><br><span class="line">// An array of auxiliary UITouch’s for touch events that are predicted to occur for a given main touch. These predictions may not exactly match the real behavior of the touch as it moves, so they should be interpreted as an estimate.</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)predictedTouchesForTouch:(UITouch *)touch API_AVAILABLE(ios(9.0));</span><br></pre></td></tr></table></figure>

<h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p><code>UIResponder</code>是iOS用于处理用户事件的API。事件响应者可以是继承自<code>UIResponder</code>的任何子类。</p>
<img data-src="/2023/03/22/iOS-%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE.png" class>
<p>关于<strong>响应者链</strong>：</p>
<ul>
<li>事件由父视图-&gt;子视图，查找最佳响应者；</li>
<li>事件由子视图-&gt;父视图在响应链进行传递，执行对应操作。</li>
</ul>
<h3 id="UIView-的-hitTest"><a href="#UIView-的-hitTest" class="headerlink" title="UIView 的 hitTest"></a>UIView 的 hitTest</h3><p>一个事件的响应者的完成经历的两个过程：</p>
<ol>
<li>hitTest方法命中视图和响应者链确定响应者。</li>
<li>hitTest方法进行查找，直到找到命中者，然后从命中者视图沿着响应链往上层寻找最终响应者。（形成响应者链）</li>
</ol>
<p><code>hitTest</code>的查找顺序：</p>
<ul>
<li>从父视图到子视图，即从<code>UIApplication</code>开始往下调用。</li>
<li>同视图层级间，同栈一样先入后出。</li>
</ul>
<p>通过调用栈复现原理伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</span><br><span class="line">    if ([self pointInside:point withEvent:event] == NO) return nil;</span><br><span class="line"></span><br><span class="line">    // 从后往前遍历子控件</span><br><span class="line">    NSInteger count = self.subviews.count;</span><br><span class="line">    for (NSInteger i = count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        UIView *childView = self.subviews[i]; // 获取子视图</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView];  // 坐标系转换</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line">        if (fitView) &#123; // 寻找到最合适的view</span><br><span class="line">            return fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 循环结束,表示没有比自己更合适的view</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不能响应触摸事件的几种Case：</p>
<ol>
<li>触摸点超出视图范围；</li>
<li>UIView的userInteractionEnabled &#x3D; NO；</li>
<li>UIView.hidden &#x3D; YES;</li>
<li>UIView.alpha &lt; 0.01;</li>
</ol>
<p>当子视图超出父视图时，可通过重写父视图的<code>hitTest</code>方法，来响应子视图的点击事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    UIView *view = [super hitTest:point withEvent:event];</span><br><span class="line">    // 超出父视图响应区域时，遍历子view区域</span><br><span class="line">    if (view == nil) &#123;</span><br><span class="line">        for (UIView *subView in self.subviews) &#123;</span><br><span class="line">            // 转换坐标系</span><br><span class="line">            CGPoint p = [subView convertPoint:point fromView:self];</span><br><span class="line">            if (CGRectContainsPoint(subView.bounds, p)) &#123;</span><br><span class="line">                view = subView;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UIResponder-1"><a href="#UIResponder-1" class="headerlink" title="UIResponder"></a>UIResponder</h3><p>关于<code>UIResponder</code>需要了解的一些属性&amp;方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// hitTest查找第一响应者的过程会形成一个响应者链，app会优先调用第一响应者处理事件，如果第一响应者不能处理事件，则调用`nextResponder`，直到找到响应链中能处理该事件的对象，都不能响应则抛弃该事件。</span><br><span class="line">@property(nonatomic, readonly, nullable) UIResponder *nextResponder;</span><br><span class="line">@property(nonatomic, readonly) BOOL canBecomeFirstResponder;    // default is NO</span><br><span class="line">- (BOOL)becomeFirstResponder;</span><br><span class="line">@property(nonatomic, readonly) BOOL canResignFirstResponder;    // default is YES</span><br><span class="line">- (BOOL)resignFirstResponder;</span><br><span class="line">@property(nonatomic, readonly) BOOL isFirstResponder;</span><br><span class="line"></span><br><span class="line">// 响应触摸事件：触摸对象集合、事件对象。</span><br><span class="line">// touchesBegan默认不对事件进行处理，单纯将事件沿着默认的响应链传递。如果要拦截事件，且不传递，重写方法但不调用父类该方法。</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; </span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches API_AVAILABLE(ios(9.1));</span><br></pre></td></tr></table></figure>

<h2 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h2><p>手势类型有很多种（子类多），API中使用最多的就是<code>- (void)addTarget:(id)target action:(SEL)action;</code>方法了，通常在自定义手势操作时会依赖<code>Began、Changed、Ended、Cancelled</code>等<code>UIGestureRecognizerState</code>状态来进行响应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123;</span><br><span class="line">    UIGestureRecognizerStatePossible, </span><br><span class="line">    UIGestureRecognizerStateBegan,     </span><br><span class="line">    UIGestureRecognizerStateChanged,    </span><br><span class="line">    UIGestureRecognizerStateEnded,      </span><br><span class="line">    UIGestureRecognizerStateCancelled,  </span><br><span class="line">    UIGestureRecognizerStateFailed,     </span><br><span class="line">    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>UIGestureRecognizer</code>同样可以响应<code>touchesBegan</code>等方法，相关声明位于<code>UIGestureRecognizerSubclass</code>中。</p>
<p><code>UIEvent</code>事件处理过程：手势上下文<code>UIGestureEnvironment</code>收到事件，通知给相关的<code>UIGestureRecognizer</code>，同时会通过<code>delegate</code>方法来判断是否能够对触摸事件进行响应。</p>
<p>手势冲突处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将手势置于另一手势优先级之下，只有另一手势识别失败才会识别该手势；另一手势识别成功，该手势状态变为识别失败。</span><br><span class="line">- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer;</span><br><span class="line">// 返回YES第一个手势失效（适用于不同层级间，返回NO不保证生效，单一控制优先级）</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer API_AVAILABLE(ios(7.0));</span><br><span class="line">// 返回YES第二个手势失效（适用于不同层级间，返回NO不保证生效，单一控制优先级）</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer API_AVAILABLE(ios(7.0));</span><br></pre></td></tr></table></figure>

<p>UIGestureRecognizer VS. UIResponder:</p>
<img data-src="/2023/03/22/iOS-%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81/UIGestureRecognizer%E5%92%8CUIResponder.svg" class>

<h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p><code>UIButton</code>继承自<code>UIControl</code>继承自<code>UIView</code>继承自<code>UIResponder</code>继承自<code>NSObject</code>。</p>
<p><code>UIControl</code>通过<code>Target-Action</code>机制处理触摸事件。</p>
<ul>
<li><code>Target-Action</code>机制通过<code>- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event;</code>方法通知<code>UIApplication</code>。</li>
<li><code>UIApplication</code>通过<code>- (BOOL)sendAction:(SEL)action to:(nullable id)target from:(nullable id)sender forEvent:(nullable UIEvent *)event;</code>方法向<code>target</code>发送<code>action</code>。</li>
<li><code>target == nil</code>时会沿着响应链进行寻找。</li>
</ul>
<p><code>UIControl</code>将手势与<code>UIView</code>进行绑定，并对<code>UIResponder</code>事件进行了重写，会阻断响应链（重写了对应实现）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    @objc func clickBtn() &#123;</span><br><span class="line">        print(&quot;======click======&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func clickView() &#123;</span><br><span class="line">        print(&quot;======clickView======&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line">        let tap = UITapGestureRecognizer(target: self, action: #selector(clickView))</span><br><span class="line">        view.addGestureRecognizer(tap)</span><br><span class="line">        </span><br><span class="line">        let btn = UIButton()</span><br><span class="line">        btn.backgroundColor = .orange</span><br><span class="line">        btn.frame = CGRect(x: 100, y: 200, width: 100, height: 100)</span><br><span class="line">        // isUserInteractionEnabled默认开启，会阻断响应链</span><br><span class="line">        //btn.isUserInteractionEnabled = false;</span><br><span class="line">        btn.addTarget(self, action: #selector(clickBtn), for: .touchUpInside)</span><br><span class="line">        view.addSubview(btn)</span><br><span class="line">        </span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br></pre></td></tr></table></figure>

<hr>
<p>Tips：</p>
<ul>
<li>响应优先级：<code>UIControl</code> &gt; <code>UIGestureRecognizer</code> &gt; <code>UITouch</code></li>
<li>userInteractionEnabled，UIView的交互属性。</li>
<li><code>exclusiveTouch</code>，UIView会独占整个Touch事件，但不影响Gesture。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIResponder</tag>
        <tag>UIGestureRecognizer</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS八股文——01</title>
    <url>/2023/04/08/iOS%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%9401/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul>
<li>open，Swift3新增访问控制符，可跨module访问，open修饰的类可继承，修饰的方法可重写。</li>
<li>public，可跨module访问，public修饰的类可访问不可被继承，修饰的方法可访问不可被重写。</li>
<li>internal，Swift中默认的访问控制符（缺省），只对自身module内开放所有源文件，对外界屏蔽代码。</li>
<li>fileprivate，Swift3新增访问控制符，可在当前文件内所有类访问。</li>
<li>private，仅可在本类中访问，extension中不可访问。</li>
</ul>
<p>Tips：<br>在Swift3中新增了访问控制修饰符，使得Swift的访问控制更加灵活。<br>使用不同访问修饰符，可以有效降低耦合，对外界屏蔽实现细节。<br>Objective-C是动态处理语言，private只是所谓的私有，通过KVC还是能够获取。<br>Swift由于性能的考虑，默认关闭了动态处理。</p>
<h2 id="Class-VS-Struct"><a href="#Class-VS-Struct" class="headerlink" title="Class VS Struct"></a>Class VS Struct</h2><p>两种数据结构，<br>Class是引用类型，当进行值传递的时候，传递的是对instance的引用；<br>Struct是值类型，当进行值传递的时候，会copy传递的值。</p>
<p>相同点：</p>
<ul>
<li>都能定义Property、Method、Initializers。</li>
<li>都支持Protocol、Extension。<br>不同点：</li>
<li>Class是引用类型，Struct是值类型。</li>
<li>Class支持继承，Struct不支持。</li>
<li>Struct声明的方法属性修改需要<code>mutating</code>关键字，Class不需要。</li>
<li>Class支持引用计数和<code>Deinitializers</code>（释放实例deinit），Struct不支持。</li>
<li>Struct提供默认的<code>memberwise initializer</code>（自动执行初始化器，对每个存储属性进行赋值）。</li>
<li>Class支持<code>type casting</code>（类型判断 is or as）。</li>
</ul>
<p>对instance的判等使用<code>===</code>或<code>!==</code>。<br><code>==</code>，判别的是两个变量或常量的值是否相同，<br>自定义的class需要遵守Equatable协议才能支持<code>==</code>操作。</p>
<p>Struct存储在stack中，Class存储在heap中，<br>相对来说，Struct效率更高，而且不需要考虑内存泄漏和多线程读写问题（copy的好处）。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例一旦创建，一直持有，不能手动销毁，但可以重置数据。如果需要的话，可以添加一个重置数据的方法。</p>
<h3 id="Swift单例模式"><a href="#Swift单例模式" class="headerlink" title="Swift单例模式"></a>Swift单例模式</h3><p>主要是利用静态成员自动满足dispatch_once规则。<br>一般通过一个静态属性<code>shared</code>持有唯一实例，通过重写<code>init()</code>防止外部调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class Single &#123;</span><br><span class="line">    static let shared = Single()</span><br><span class="line">    private init() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其它都是基于此的一些变形，如：</span><br><span class="line">final class Single1 &#123;</span><br><span class="line">    static let shared = &#123;</span><br><span class="line">        let instance = Single1()</span><br><span class="line">        return instance</span><br><span class="line">    &#125;()</span><br><span class="line">    private init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h3><p>.h文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Singleton : NSObject</span><br><span class="line">+(instancetype)shareInstances;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>.m文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@implementation Singleton</span><br><span class="line"></span><br><span class="line">static Singleton* _instance = nil;</span><br><span class="line"></span><br><span class="line">+(instancetype) shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken ;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[super allocWithZone:NULL] init] ;</span><br><span class="line">    &#125;) ;</span><br><span class="line"></span><br><span class="line">    return _instance ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(id) allocWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    return [Singleton shareInstance] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(id) copyWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    return [Singleton shareInstance] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>访问控制</tag>
        <tag>Class VS Struct</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS实现点九图效果</title>
    <url>/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>点九图是Android特有的切图方式，iOS也可以通过简单的图片操作来实现（调用<code>UIImage</code>的<code>resizableImage</code>方法即可）。</p>
<p>iOS开发中经常会遇到比较复杂的异形图的绘制或者添加一些纹理，比较简单的办法就是找UI同学给个切图。但是固定图片在不同屏幕大小机型上会被拉伸，效果会比较差。因此，可以使用点九图（Android特有说法）来实现复杂处理。比较典型的例子就是WeChat中的聊天输入框。</p>
<span id="more"></span>

<p><a href="https://zhuanlan.zhihu.com/p/97138527">点九图的原理：</a></p>
<img data-src="/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/%E7%82%B9%E4%B9%9D%E5%9B%BE%E5%8E%9F%E7%90%86.png" class>
<p>对于一张图片，可以通过上下左右分别绘制两天直线来对图片进行划分，将图片划分为9个区域。在该区域中，四个角落即1、2、3、4区域是不可拉伸的，其它区域均可被拉伸。<br>实现原理则是，程序通过识别图片四周的1px的直线（需要设计给出），实现对拉伸区域（6左边和5上边）和文本区域（7右边和8下边）的定义。</p>
<ul>
<li>拉伸区域：6左边可实现纵向拉伸，5上边可实现横向拉伸。</li>
<li>文本区域：7右边和8下边来避免文本区域超出圆角区域。</li>
</ul>
<p>随便找了一张图来实践一下，<br>对下述图片进行操作：</p>
<img data-src="/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/end_time.jpeg" class>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//: A UIKit based Playground for presenting user interface</span><br><span class="line">  </span><br><span class="line">import UIKit</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">class MyViewController : UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    override func loadView() &#123;</span><br><span class="line">        let view = UIView()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line">        </span><br><span class="line">        let img = UIImageView()</span><br><span class="line">        if let path = Bundle.main.path(forResource: &quot;end_time&quot;, ofType: &quot;jpeg&quot;) &#123;</span><br><span class="line">            if let data: Data = NSData(contentsOfFile: path) as Data? &#123;</span><br><span class="line">                let image = UIImage(data: data)</span><br><span class="line">                img.image = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        img.frame = CGRect(x: 100, y: 0, width: 120, height: 48)</span><br><span class="line">        view.addSubview(img)</span><br><span class="line">        </span><br><span class="line">        let img1 = UIImageView()</span><br><span class="line">//        img1.contentMode = .topLeft   // 默认使用</span><br><span class="line">        img1.image = UIImage(named: &quot;end_time.jpeg&quot;)</span><br><span class="line">        img1.frame = CGRect(x: 100, y: 100, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img1)</span><br><span class="line">        </span><br><span class="line">        let img2 = UIImageView()</span><br><span class="line">        img2.contentMode = .scaleAspectFit</span><br><span class="line">        img2.image = UIImage(named: &quot;end_time.jpeg&quot;)</span><br><span class="line">        img2.frame = CGRect(x: 100, y: 200, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img2)</span><br><span class="line">        </span><br><span class="line">        let img3 = UIImageView()</span><br><span class="line">        img3.image = UIImage(named: &quot;end_time.jpeg&quot;)?.resizableImage(withCapInsets: .init(top: 0, left: 0, bottom: 0, right: 0), resizingMode: .stretch)</span><br><span class="line">        img3.frame = CGRect(x: 100, y: 300, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img3)</span><br><span class="line">        </span><br><span class="line">        let img4 = UIImageView()</span><br><span class="line">        img4.image = UIImage(named: &quot;end_time.jpeg&quot;)?.resizableImage(withCapInsets: .init(top: 0, left: 40, bottom: 0, right: 50), resizingMode: .stretch)</span><br><span class="line">        img4.frame = CGRect(x: 100, y: 400, width: 200, height: 48)</span><br><span class="line">        view.addSubview(img4)</span><br><span class="line">        </span><br><span class="line">        let img5 = UIImageView()</span><br><span class="line">        img5.image = UIImage(named: &quot;end_time.jpeg&quot;)?.resizableImage(withCapInsets: .init(top: 20, left: 40, bottom: 20, right: 50), resizingMode: .stretch)</span><br><span class="line">        img5.frame = CGRect(x: 100, y: 500, width: 200, height: 100)</span><br><span class="line">        view.addSubview(img5)</span><br><span class="line">        </span><br><span class="line">        self.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Present the view controller in the Live View window</span><br><span class="line">PlaygroundPage.current.liveView = MyViewController()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现代码效果如下：</p>
<img data-src="/2023/03/29/iOS%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%B9%9D%E5%9B%BE%E6%95%88%E6%9E%9C/%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C.png" class>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>从零创建一个iOS端app——01创建工程</title>
    <url>/2023/04/03/%E4%BB%8E%E9%9B%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAiOS%E7%AB%AFapp%E2%80%94%E2%80%9401%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h2 id="创建工程（AppHome）"><a href="#创建工程（AppHome）" class="headerlink" title="创建工程（AppHome）"></a>创建工程（AppHome）</h2><ol>
<li>打开Xcode，选择<code>Create a new Xcode project</code> ;</li>
<li>点击<code>iOS</code>tab，选择<code>App</code>；</li>
<li>填写应用相关内容：<img data-src="/2023/04/03/%E4%BB%8E%E9%9B%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAiOS%E7%AB%AFapp%E2%80%94%E2%80%9401%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B.png" class><ul>
<li><code>Product Name</code>，app名称</li>
<li><code>Team</code>开发者账号，选择None只能使用模拟器</li>
<li><code>Organization Identifier</code>，组织唯一标识，一般使用网站域名倒写</li>
<li><code>Bundle Identifier</code>，应用唯一标识，<strong>不可修改</strong></li>
<li><code>Interface</code>，接口，选择Storyboard</li>
<li><code>Language</code>，语言，选择Swift</li>
<li><code>Use Core Data</code>，是否使用持久化数据存储，暂不需要，先不勾选</li>
<li><code>Include Tests</code>，添加测试类，不需要，取消勾选</li>
</ul>
</li>
<li>选择存储位置，等待创建完成。</li>
<li>本地打开工程文件，添加Pod依赖库：<ul>
<li>本地没有安装<code>CocoaPods</code>的话需要提前安装；</li>
<li>命令行创建pod依赖<code>pod init</code>；</li>
<li><code>Podfile</code>添加依赖库；</li>
<li>更新pod依赖<code>pod install --repo-update</code>。</li>
</ul>
</li>
<li>打开<code>***.xcworkspace</code>工程即可开始编写app。</li>
</ol>
<h2 id="Assets-xcassets"><a href="#Assets-xcassets" class="headerlink" title="Assets.xcassets"></a>Assets.xcassets</h2><p>资源文件管理的地方，一般用于存放图片等资源文件。iOS 11之后也可存放颜色组（可用于适配深色模式）。</p>
<h3 id="AppIcon"><a href="#AppIcon" class="headerlink" title="AppIcon"></a>AppIcon</h3><p>推荐几个好用的图片相关网站：</p>
<ul>
<li>图片压缩：<a href="https://tinypng.com/">https://tinypng.com</a></li>
<li>生成<code>app icon</code>：<a href="https://www.appicon.co/">https://www.appicon.co</a> </li>
<li>IconFont：<a href="https://www.iconfont.cn/">https://www.iconfont.cn</a></li>
</ul>
<p>将生成好的icon图片添加到主工程<code>Assets.xcassets</code>中<code>AppIcon</code>占位图即可。</p>
<h3 id="AccentColor"><a href="#AccentColor" class="headerlink" title="AccentColor"></a>AccentColor</h3><p><strong>iOS11才支持</strong>，统一管理颜色，方便开发进行颜色替换。</p>
<p>主题色，右侧<code>Color Set</code>下的<code>Appearances</code>可选择<code>Any,Dark</code>，设置默认风格和黑暗风格的颜色。</p>
<p>调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swift</span><br><span class="line">bkg.backgroundColor = UIColor(named: &quot;theme_color&quot;)</span><br><span class="line"></span><br><span class="line">object-c</span><br><span class="line">bkg.backgroundColor = [UIColor colorNamed:@&quot;theme_color&quot;];</span><br></pre></td></tr></table></figure>

<h2 id="添加底tab"><a href="#添加底tab" class="headerlink" title="添加底tab"></a>添加底tab</h2><ul>
<li>AppDelegate是iOS中应用程序的主要入口点。Apple为几个应用程序级生命周期事件调用AppDelegate方法。</li>
<li>当AppDelegate是负责应用程序生命周期的对象时，<code>SceneDelegate</code>负责屏幕上显示的内容（scenes or windows）。当你处理scene时，对你的用户来说看起来像window的东西实际上被称为UIScene，它是由UISceneSession管理的。当我们提到windows时，我们实际上指的是UISceneSession对象。</li>
</ul>
<p>通常一个app中，首页都是一个底tab（UITabBarController）可供用户选择不同的功能场景：</p>
<ol>
<li>创建一个<code>UITabBarController</code>；</li>
<li>创建多个<code>UIViewController</code>，并设置VC的<code>tabBarItem</code>；</li>
<li>将生成的多个VC添加到tabBar的viewControllers；</li>
<li>在<code>SceneDelegate</code>的<code>scene</code>方法中将tabBar设置为window的<code>rootViewController</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) &#123;</span><br><span class="line">    let tabbar = UITabBarController()</span><br><span class="line">    window?.rootViewController = tabbar</span><br><span class="line">    guard let _ = (scene as? UIWindowScene) else &#123; return &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="tabBarItem图片大小问题"><a href="#tabBarItem图片大小问题" class="headerlink" title="tabBarItem图片大小问题"></a>tabBarItem图片大小问题</h3><p>找了两张图片，发现尺寸过大，导致图片超出父视图区域。<br>看网上方法基本都是修改<code>tabBarItem.imageInsets</code>，试了之后发现没有生效。<br>所以，还是重新绘制一下吧。</p>
<p>写了一个工具类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ImageTools &#123;</span><br><span class="line">    // 裁剪图片到指定大小</span><br><span class="line">    class func tailorImage(image: UIImage?, newSize: CGSize) -&gt; UIImage &#123;</span><br><span class="line">        guard let originImg = image else &#123;</span><br><span class="line">            return UIImage()</span><br><span class="line">        &#125;</span><br><span class="line">        UIGraphicsBeginImageContext(newSize)</span><br><span class="line">        originImg.draw(in: CGRect(origin: CGPoint.zero, size: newSize))</span><br><span class="line">        let newImg = UIGraphicsGetImageFromCurrentImageContext() ?? originImg</span><br><span class="line">        UIGraphicsEndImageContext()</span><br><span class="line">        return newImg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tabBarItem单独设置文字颜色和图片颜色"><a href="#tabBarItem单独设置文字颜色和图片颜色" class="headerlink" title="tabBarItem单独设置文字颜色和图片颜色"></a>tabBarItem单独设置文字颜色和图片颜色</h3><p>设置tabBar的tintColor会同时修改tabBarItem的图片和文字颜色，需要对文字颜色单独进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tabBar.tintColor = .orange</span><br><span class="line">// 设置文字颜色不跟随tintColor</span><br><span class="line">UITabBarItem.appearance().setTitleTextAttributes([NSAttributedString.Key.foregroundColor: UIColor(named: &quot;textColor&quot;) ?? .tintColor], for: .selected)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
        <category>从零创建一个iOS端app</category>
      </categories>
  </entry>
  <entry>
    <title>从零创建一个iOS端app——02创建Pod库</title>
    <url>/2023/04/05/%E4%BB%8E%E9%9B%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAiOS%E7%AB%AFapp%E2%80%94%E2%80%9402%E5%88%9B%E5%BB%BAPod%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h2 id="本地创建一个Pod工程"><a href="#本地创建一个Pod工程" class="headerlink" title="本地创建一个Pod工程"></a>本地创建一个Pod工程</h2><ol>
<li>起一个Pod仓库名，使用<code>pod lib lint 仓库名</code>来校验是否被占用。 </li>
<li>命令行输入<code>pod lib create 仓库名</code>，之后会克隆CocoaPods的<code>pod-template</code>到该仓库。<br>在执行这个命令的时候，遇到了两个问题：<ul>
<li><code>Ignoring ffi-1.15.5 because its extensions are not built. Try: gem pristine ffi --version 1.15.5</code>，解决方案：<ol>
<li><code>brew install rbenv</code></li>
<li><code>rbenv install 3.1.2</code></li>
<li><code>rbenv global 3.1.2</code></li>
<li><code>sudo gem install ffi --version 1.15.5 --user-install</code></li>
</ol>
</li>
<li><code> Could not find &#39;rexml&#39; (~&gt; 3.2.4) - did find: [rexml-3.1.9.1] (Gem::MissingSpecVersionError)</code>，解决方案：<code>sudo gem update rexml</code>更新一下rexml版本。</li>
</ul>
</li>
<li>创建过程中会有一些输入，根据自己需要来添加即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS</span><br><span class="line"></span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; Swift</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; Yes</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Quick / None ]</span><br><span class="line"> &gt; None</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line"> &gt; NO</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="本地仓库测试"><a href="#本地仓库测试" class="headerlink" title="本地仓库测试"></a>本地仓库测试</h2><p>在<code>**.podspec</code>中添加一些子仓需要的依赖（同<code>Podfile</code>），如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.dependency &#x27;SnapKit&#x27;, &#x27;~&gt; 5.0.0&#x27;</span><br></pre></td></tr></table></figure>

<p>对Classes中的<code>ReplaceMe.swift</code>文件进行替换。</p>
<p>对子仓中的Example工程进行<code>pod install</code>，编写测试方法即可。</p>
<h2 id="创建-amp-添加到远端仓库"><a href="#创建-amp-添加到远端仓库" class="headerlink" title="创建&amp;添加到远端仓库"></a>创建&amp;添加到远端仓库</h2><ol>
<li>在GitHub创建一个同名Repo。</li>
<li>修改本地仓的<code>**.podspec</code>文件，修改<code>s.homepage</code>和<code>s.source</code>等必要信息。</li>
<li>本地仓库与远程仓库关联（换成自己的）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/newbieCV/AHComponents.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></li>
<li>git提交本地仓修改</li>
</ol>
<h2 id="添加tag标签"><a href="#添加tag标签" class="headerlink" title="添加tag标签"></a>添加tag标签</h2><p>在引入子仓依赖时，都会指定一个版本号（tag标记）。<br>为了方便被引用，需要对当前代码提交打个tag标记。</p>
<p>在本地子仓中设置tag标记，并push到远端。<br>更新完成后在远端仓库可以看到如图所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag 0.1.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h2 id="发布到Cocoapods"><a href="#发布到Cocoapods" class="headerlink" title="发布到Cocoapods"></a>发布到Cocoapods</h2><p>在发布前，需要对当前子仓的podspec的合法性进行检查。可选择<code>--allow-warnings</code>忽略警告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod lib lint --verbose</span><br></pre></td></tr></table></figure>

<p>如果本地验证通过（终端最后出现<code>*** passed validation.</code>），则可以继续提交到Cocoapods。</p>
<p>提交podspec仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod trunk push ***.podspec --verbose</span><br></pre></td></tr></table></figure>

<hr>
<p>或许高兴早了？<br><code>[!] You need to run </code>pod trunk register<code> to register a session first.</code></p>
<p>那就注册一下trunk吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod trunk register 电子邮箱 &#x27;姓名&#x27; --description=&#x27;macbook pro&#x27;</span><br></pre></td></tr></table></figure>

<p>随后出现<code>[!] Please verify the session by clicking the link in the verification email that has been sent to zhangzongyu00@gmail.com</code>，<br>打开邮箱信任一下就好。</p>
<p>查看是否注册成功：<code>pod trunk me</code>。</p>
<p>重新执行<code>pod trunk push ***.podspec --verbose</code>，<br>还不马上去工程里面调用试试 fun!</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>从零创建一个iOS端app</category>
      </categories>
  </entry>
  <entry>
    <title>响铃与震动</title>
    <url>/2023/04/15/%E5%93%8D%E9%93%83%E4%B8%8E%E9%9C%87%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>响铃和震动是音视频通话的基础功能，如何实现呢？<br>思路其实很简单，直接上代码吧</p>
<span id="more"></span>

<h2 id="响铃处理"><a href="#响铃处理" class="headerlink" title="响铃处理"></a>响铃处理</h2><p>有个区别的点在于：</p>
<ul>
<li><code>AudioServicesPlayAlertSound(soundID)</code>支持响铃和震动。</li>
<li><code>AudioServicesPlaySystemSound(soundID)</code>，仅支持响铃。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 响铃标识</span><br><span class="line">var soundID = SystemSoundID()</span><br><span class="line">// 响铃操作</span><br><span class="line">func useRing() &#123;</span><br><span class="line">    // 获取铃声资源</span><br><span class="line">    guard let path = Bundle().path(forResource: &quot;ring&quot;, ofType: &quot;mp3&quot;) else &#123; return &#125;</span><br><span class="line">    let url = NSURL(fileURLWithPath: path)</span><br><span class="line">    // 创建声音标识</span><br><span class="line">    AudioServicesCreateSystemSoundID(url, &amp;soundID)</span><br><span class="line">    // 响铃完成回调</span><br><span class="line">    AudioServicesAddSystemSoundCompletion(soundID, nil, nil, &#123; soundID, _ in</span><br><span class="line">        AudioServicesPlaySystemSound(soundID)</span><br><span class="line">    &#125;, nil)</span><br><span class="line">    // 响铃一次，完成后会自动调用完成回调，然后陷入循环</span><br><span class="line">    AudioServicesPlaySystemSound(soundID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止响铃</span><br><span class="line">func stopRing() &#123;</span><br><span class="line">    AudioServicesRemoveSystemSoundCompletion(soundID)</span><br><span class="line">    AudioServicesDisposeSystemSoundID(soundID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="震动处理"><a href="#震动处理" class="headerlink" title="震动处理"></a>震动处理</h2><p>设置一个Timer计时器，添加到runloop中去轮询就可以实现了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var endTimer = Timer()</span><br><span class="line">// 震动</span><br><span class="line">func useShake() &#123;</span><br><span class="line">    shakeTimer = Timer(timeInterval: 1, repeats: true, block: &#123; _ in</span><br><span class="line">        AudioServicesPlaySystemSound(kSystemSoundID_Vibrate)</span><br><span class="line">    &#125;)</span><br><span class="line">    RunLoop.current.add(shakeTimer, forMode: .defaultRunLoopMode)</span><br><span class="line">    // 开始计时</span><br><span class="line">    shakeTimer.fire()</span><br><span class="line">&#125;</span><br><span class="line">// 停止震动</span><br><span class="line">func stopShake() &#123;</span><br><span class="line">    shakeTimer.invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同时处理响铃与震动"><a href="#同时处理响铃与震动" class="headerlink" title="同时处理响铃与震动"></a>同时处理响铃与震动</h2><p><code>AudioServicesPlayAlertSound</code>方法虽然在响铃的同时支持震动的调用，但是震动周期与响铃一致，即每次响铃完才震动一下。<br>这种Case肯定是不能接受的，那么就分开处理呗。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func ringOrShake(type: AHRingAndShakeType, duration: TimeInterval?) &#123;</span><br><span class="line">    // 避免上次播放尚未结束</span><br><span class="line">    stopRingAndShake()</span><br><span class="line">    </span><br><span class="line">    if (type == .ringAndShake || type == .ring),</span><br><span class="line">        let path = AHTools.findSourceBundle().path(forResource: &quot;ring&quot;, ofType: &quot;mp3&quot;) &#123;</span><br><span class="line">        let url = NSURL(fileURLWithPath: path)</span><br><span class="line">        AudioServicesCreateSystemSoundID(url, &amp;soundID)</span><br><span class="line">        AudioServicesAddSystemSoundCompletion(soundID, nil, nil, &#123; soundID, _ in</span><br><span class="line">            AudioServicesPlaySystemSound(soundID)</span><br><span class="line">        &#125;, nil)</span><br><span class="line">        AudioServicesPlaySystemSound(soundID)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var durationStr: Double = duration ?? 1</span><br><span class="line">    endTimer = Timer(timeInterval: 1, repeats: true, block: &#123; [weak self] timer in</span><br><span class="line">        if (type == .shake || type == .ringAndShake) &#123;</span><br><span class="line">            AudioServicesPlaySystemSound(kSystemSoundID_Vibrate)</span><br><span class="line">        &#125;</span><br><span class="line">        if (durationStr &lt;= 0) &#123;</span><br><span class="line">            self?.stopRingAndShake()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            durationStr -= 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    RunLoop.current.add(endTimer, forMode: .defaultRunLoopMode)</span><br><span class="line">    // 开始计时</span><br><span class="line">    endTimer.fire()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止调用</span><br><span class="line">@objc</span><br><span class="line">public func stopRingAndShake() &#123;</span><br><span class="line">    endTimer.invalidate()</span><br><span class="line">    AudioServicesRemoveSystemSoundCompletion(soundID)</span><br><span class="line">    AudioServicesDisposeSystemSoundID(soundID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，为了封装，也为了更好的调用，使用了enum。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum AHRingAndShakeType &#123;</span><br><span class="line">    case ring</span><br><span class="line">    case shake</span><br><span class="line">    case ringAndShake</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ring and shake</tag>
      </tags>
  </entry>
  <entry>
    <title>我的个税退税</title>
    <url>/2023/03/20/%E6%88%91%E7%9A%84%E4%B8%AA%E7%A8%8E%E9%80%80%E7%A8%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="个人所得税"><a href="#个人所得税" class="headerlink" title="个人所得税"></a>个人所得税</h1><p>我要办税之综合所得年度汇算，在收入部分，对于年终奖部分，如果收入比较低（几千块&#x2F;月）来说，可能合并计税会比较划算；而对于身边绝大部分朋友，还是单独计税更合适。这两种计税方式可以都试下，看看到底哪个更适合自己。其次，是一些附加税的扣除。</p>
<h2 id="专项附加税扣除"><a href="#专项附加税扣除" class="headerlink" title="专项附加税扣除"></a>专项附加税扣除</h2><ul>
<li>子女教育，这个目前还没有，先不考虑</li>
<li>继续教育，这部分还有提升空间，分为两部分：<ul>
<li>学历继续教育，说实话，目前来说也不再考虑了😅</li>
<li>职业资格继续教育，这部分还可以技术提升下，有些需要一定的时间精力的，比如软考中级证书、初级会计资格证等，还有一些是不需要花费多少时间的，这种的就比较友好了。</li>
</ul>
</li>
<li>大病医疗，还没有，也不希望有 嘿嘿</li>
<li>住房贷款利息，目前还没有，快了快了</li>
<li>住房租金<ul>
<li>有一定要如实填写，这部分能有一万八的抵税额度，公司发的工资虽然已经扣除过了，但是如果自己不申报会把这部分的额度重新计税。</li>
</ul>
</li>
<li>赡养老人，父母到60岁才可以用，别的没办法</li>
<li>3岁以下婴幼儿护照，有了孩子再说吧，感觉离我还很遥远</li>
</ul>
<h2 id="职业资格认证"><a href="#职业资格认证" class="headerlink" title="职业资格认证"></a>职业资格认证</h2><h3 id="阿⾥云Apsara-Clouder云计算专项技能认证"><a href="#阿⾥云Apsara-Clouder云计算专项技能认证" class="headerlink" title="阿⾥云Apsara Clouder云计算专项技能认证"></a><a href="https://edu.aliyun.com/certification/cldc15">阿⾥云Apsara Clouder云计算专项技能认证</a></h3><p>网站：<a href="https://edu.aliyun.com/certification/cldc15">https://edu.aliyun.com/certification/cldc15</a></p>
<p><em>0成本考证填报个税纳税额减免3600</em></p>
<p>题目比较固定，大部分题目网上很多答案，直接搜就可以了。贴一个自用的链接答案 <a href="https://blog.csdn.net/spacehhy/article/details/128917928">https://blog.csdn.net/spacehhy/article/details/128917928</a></p>
<p>申报：<br>    1. <code>职业资格继续教育类型</code>选择<code>专业技术人员职业资格</code>；<br>    2. 发证日期 &amp; 证书编号，填写证书上的信息；<br>    3. <code>证书名称</code>选择<code>计算机技术与软件专业技术资格</code>；<br>    4. <code>发证机关</code>选择<code>阿里云</code>。</p>
]]></content>
      <categories>
        <category>工作相关</category>
      </categories>
      <tags>
        <tag>个人所得税</tag>
      </tags>
  </entry>
  <entry>
    <title>捕鼠器の故事</title>
    <url>/2023/03/25/%E6%8D%95%E9%BC%A0%E5%99%A8%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>
        <div id="aplayer-aNxNrTyv" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-aNxNrTyv"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "朗读这篇文章",
              author: "章肿鱼",
              url: "捕鼠器的故事.mp3",
              pic: "/images/avatar.jpeg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<p><strong>从收到一个需求，去做一件事，到解决某一类问题，这是一个坎。</strong></p>
<span id="more"></span>

<p>假设你是一个工程师，这时候你被安排了一项任务“改进捕鼠器”。<br>你就要思考🤔：这个捕鼠器要怎么改进呢？<br>通常做法：</p>
<ul>
<li>最简单的，去搜索业界类似的Case，看有没有类似的优化（借鉴已有先进经验）；</li>
<li>比较负责一点的同学，会考虑为什么现在的捕鼠器需要改进（捕鼠的效果差的原因），即实际产品的现存问题；</li>
</ul>
<p>改造过程就比作积累技术经验，一般的做完需求就stop了，不会再继续深究，获得的只限于技术的熟练或积累了类似经验。<br>进阶一步的话，就需要考虑为什么要去改进捕鼠器呢？如果回答是为了捕老鼠，这个回答无法反驳，但只是这样的话，在捕老鼠这个问题上很快就会达到一个瓶颈（毕竟技术是有限制的，<strong>捕鼠器改进再好，老鼠不过去，也很难抓到老鼠</strong>）。</p>
<p>改造完成后通过观察（自测、内测、众测等）发现，核心问题是捕鼠器的位置不对。（这是关键点，<strong>一个RD对一个任务能够从解决问题到提出新问题是一个突破</strong>）<br>针对这个发现，已经不是捕鼠器的问题了，而是环境的限制。<br>此时就会想，使用捕鼠器的原因，本质上其实是为了根除老鼠。所以，捕鼠器本身不重要，重要的是能够杀死老鼠。<br>鉴于此，就有了进一步横向思考的可能，比如说发明捕鼠药，有的话直接购买也可以的。（这时会发现自己已经有了新的需求，如何改进灭鼠药的效果😂）</p>
<p>其实这个故事，灭鼠不是关键，灭鼠是为了保护粮食。当把老鼠都消灭之后发现粮食还是保不住（比如，被雨水淋坏了等）。<br>再继续深入就会发现，最终的OKR其实是为了保护粮食。那么，如何定义保护粮食是否有提升呢？比如，粮食留存率等等，这时候就可以去定义粮食保护的评估方法，进而成立粮食保护小组（可以带团队创业了）。</p>
<img data-src="/2023/03/25/%E6%8D%95%E9%BC%A0%E5%99%A8%E7%9A%84%E6%95%85%E4%BA%8B/%E6%A6%82%E8%A7%88.png" class>
<blockquote>
<p>杨震原说过，对研发来说，前提是能够把现有本职工作做好，如果能进一步去思考问题的本质，能够跟最高的目标对齐，你的工作实际上会更加主动，也能更好发挥自己的能力。</p>
</blockquote>
<p>所以，经常想想自己在做的问题，“你在解决什么问题？”；<br>假如你是leader，还可以对员工继续提问：“这真的是你的问题吗😏”</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>iOS添加高德地图</title>
    <url>/2023/04/15/iOS%E6%B7%BB%E5%8A%A0%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h2 id="基础准备工作"><a href="#基础准备工作" class="headerlink" title="基础准备工作"></a>基础准备工作</h2><p><a href="https://console.amap.com/dev/index">高德地图官网</a>申请APIKey。</p>
<p>podspec或podfile添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.dependency &#x27;AMap3DMap-NO-IDFA&#x27;, &#x27;~&gt; 8.1.0&#x27;</span><br><span class="line">s.dependency &#x27;AMapSearch-NO-IDFA&#x27;, &#x27;~&gt; 8.1.0&#x27;</span><br><span class="line">s.dependency &#x27;AMapLocation-NO-IDFA&#x27;, &#x27;~&gt; 2.8.0&#x27;</span><br><span class="line">s.dependency &#x27;AMapFoundation-NO-IDFA&#x27;, &#x27;~&gt; 1.6.9&#x27;</span><br></pre></td></tr></table></figure>

<p><code>info.plist</code>添加https支持：</p>
<img data-src="/2023/04/15/iOS%E6%B7%BB%E5%8A%A0%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/%E6%B7%BB%E5%8A%A0https%E6%94%AF%E6%8C%81.png" class>

<p>添加基本配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// APIkey需要自行到官网获取</span><br><span class="line">AMapServices.shared().apiKey = key</span><br><span class="line">// 更新协议，8.1.0版本开始</span><br><span class="line">MAMapView.updatePrivacyAgree(.didAgree)</span><br><span class="line">MAMapView.updatePrivacyShow(.didShow, privacyInfo: .didContain)</span><br><span class="line">// 打开https开关</span><br><span class="line">AMapServices.shared().enableHTTPS = true</span><br></pre></td></tr></table></figure>

<h2 id="地图配置-amp-定位权限"><a href="#地图配置-amp-定位权限" class="headerlink" title="地图配置 &amp; 定位权限"></a>地图配置 &amp; 定位权限</h2><p>添加地图，不能使用懒加载写法（否则出不来就离谱）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mapView = MAMapView(frame: CGRect(origin: .zero, size: CGSize(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height - 100)))</span><br><span class="line">mapView.delegate = self // 需要前置</span><br><span class="line">mapView.showsUserLocation = true</span><br><span class="line">mapView.compassOrigin = CGPoint(x: UIScreen.main.bounds.width - 40, y: 80)</span><br><span class="line">mapView.zoomLevel = 13</span><br><span class="line">view.addSubview(mapView)</span><br></pre></td></tr></table></figure>

<p><code>info.plist</code>添加定位权限支持：</p>
<img data-src="/2023/04/15/iOS%E6%B7%BB%E5%8A%A0%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/%E6%B7%BB%E5%8A%A0%E5%AE%9A%E4%BD%8D%E6%9D%83%E9%99%90%E6%94%AF%E6%8C%81.png" class>

<p>开启定位权限，需实现<code>MAMapViewDelegate</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public func mapViewRequireLocationAuth(_ locationManager: CLLocationManager!) &#123;</span><br><span class="line">    locationManager.requestAlwaysAuthorization()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动定位到当前定位位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var isFirstLoadMap = false</span><br><span class="line">/// 基于定位位置，在定位回调中进行POI搜索和逆地理编码</span><br><span class="line">public func mapView(_ mapView: MAMapView!, didUpdate userLocation: MAUserLocation!, updatingLocation: Bool) &#123;</span><br><span class="line">    if !updatingLocation || userLocation.location.horizontalAccuracy &lt; 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if !isFirstLoadMap &#123;</span><br><span class="line">        isFirstLoadMap = true</span><br><span class="line">        mapView.centerCoordinate = userLocation.location.coordinate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><p>地图自适应大小，<a href="https://lbs.amap.com/demo/sdk/map-zoomtospan#ios">根据传入的经纬度数组自动调整地图大小</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func showsAnnotations(_ annotations: [MAPointAnnotation], edgePadding insets:UIEdgeInsets, _ mapView: MAMapView) &#123;</span><br><span class="line">        var rect:MAMapRect = MAMapRectZero</span><br><span class="line"></span><br><span class="line">        for annotation:MAPointAnnotation in annotations &#123;</span><br><span class="line">            let diagonalPoint:CLLocationCoordinate2D = CLLocationCoordinate2DMake(mapView.centerCoordinate.latitude - (annotation.coordinate.latitude - mapView.centerCoordinate.latitude),mapView.centerCoordinate.longitude - (annotation.coordinate.longitude - mapView.centerCoordinate.longitude))</span><br><span class="line"></span><br><span class="line">            let annotationMapPoint: MAMapPoint = MAMapPointForCoordinate(annotation.coordinate)</span><br><span class="line">            let diagonalPointMapPoint: MAMapPoint = MAMapPointForCoordinate(diagonalPoint)</span><br><span class="line"></span><br><span class="line">            let annotationRect:MAMapRect = MAMapRectMake(min(annotationMapPoint.x, diagonalPointMapPoint.x), min(annotationMapPoint.y, diagonalPointMapPoint.y), abs(annotationMapPoint.x - diagonalPointMapPoint.x), abs(annotationMapPoint.y - diagonalPointMapPoint.y));</span><br><span class="line"></span><br><span class="line">            rect = MAMapRectUnion(rect, annotationRect)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mapView.setVisibleMapRect(rect, edgePadding: insets, animated: true)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
</search>
